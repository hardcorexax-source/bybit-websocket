<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ñ–∏–≤–æ–π —Å–≤–µ—á–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫ BTC/USDT —Å –∏—Å—Ç–æ—Ä–∏–µ–π</title>

  <!-- Highcharts Stock -->
  <script src="https://code.highcharts.com/stock/highstock.js"></script>
  <script src="https://code.highcharts.com/modules/exporting.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 40px;
      background: #f3f4f6;
    }
    #container {
      height: 600px;
      min-width: 600px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
  </style>
</head>
<body>

<h2>üíπ –ñ–∏–≤–æ–π —Å–≤–µ—á–Ω–æ–π –≥—Ä–∞—Ñ–∏–∫ BTC/USDT —Å –∏—Å—Ç–æ—Ä–∏–µ–π</h2>
<div id="container"></div>

<script>
const MAX_VISIBLE_CANDLES = 50; // –≤—Å–µ–≥–¥–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º 50 —Å–≤–µ—á–µ–π
const series = chart.series[0];
const candles = [];

const candleInterval = 60000; // 1 –º–∏–Ω—É—Ç–∞ –≤ –º—Å

async function loadHistory() {
  const url = `https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=100`;
  const response = await fetch(url);
  const data = await response.json();

  data.forEach(c => {
    const candle = [
      c[0],
      parseFloat(c[1]),
      parseFloat(c[2]),
      parseFloat(c[3]),
      parseFloat(c[4])
    ];
    candles.push(candle);
    series.addPoint(candle, false);
  });
  chart.redraw();
}

function initWebSocket() {
  const socket = new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@trade');

  socket.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    const price = parseFloat(msg.p);
    const time = msg.T;
    const candleTime = Math.floor(time / candleInterval) * candleInterval;

    let candle = candles.find(c => c[0] === candleTime);

    if (!candle) {
      candle = [candleTime, price, price, price, price];
      candles.push(candle);

      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –∫–æ–Ω—Ü–µ –≥—Ä–∞—Ñ–∏–∫–∞ –∏–ª–∏ –æ—Ç–¥–∞–ª–∏–ª
      const xAxis = chart.xAxis[0];
      const maxVisible = xAxis.max;
      const isAtEnd = maxVisible >= series.data[series.data.length - 1].x;

      series.addPoint(candle, true, isAtEnd && series.data.length >= MAX_VISIBLE_CANDLES);
    } else {
      candle[2] = Math.max(candle[2], price);
      candle[3] = Math.min(candle[3], price);
      candle[4] = price;
      const lastPoint = series.data[series.data.length - 1];
      lastPoint.update(candle, true, true);
    }
  };

  socket.onerror = (err) => console.error("WebSocket –æ—à–∏–±–∫–∞:", err);
  socket.onclose = () => console.warn("WebSocket –∑–∞–∫—Ä—ã—Ç");
}

// –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≤–∏–¥–∏–º—ã—Ö —Å–≤–µ—á–µ–π –ø—Ä–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–∏
chart.xAxis[0].update({
  events: {
    afterSetExtremes: function (e) {
      const xAxis = this;
      const visiblePoints = series.points.filter(p => p.x >= e.min && p.x <= e.max);
      if (visiblePoints.length > MAX_VISIBLE_CANDLES) {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ç–æ—á–∫–∏, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –æ—Ç–¥–∞–ª–∏–ª –≥—Ä–∞—Ñ–∏–∫
        const excess = visiblePoints.length - MAX_VISIBLE_CANDLES;
        for (let i = 0; i < excess; i++) {
          series.data[i].remove(false);
        }
        chart.redraw();
      }
    }
  }
});

loadHistory().then(initWebSocket);
</script>

</body>
</html>
